// Generated by CIRCT unknown git version
module handshake_buffer_in_ui1_out_ui1_2slots_seq(
  input  in0,
         in0_valid,
         clock,
         reset,
         out0_ready,
  output in0_ready,
         out0,
         out0_valid
);

  reg  ready1_reg;
  reg  ready0_reg;
  reg  valid0_reg;
  wire _GEN = ~valid0_reg | ~ready0_reg;
  reg  data0_reg;
  reg  ctrl_data0_reg;
  reg  valid1_reg;
  wire _GEN_0 = ~valid1_reg | ~ready1_reg;
  reg  data1_reg;
  reg  ctrl_data1_reg;
  always_ff @(posedge clock) begin
    if (reset) begin
      valid0_reg <= 1'h0;
      data0_reg <= 1'h0;
      ready0_reg <= 1'h0;
      ctrl_data0_reg <= 1'h0;
      valid1_reg <= 1'h0;
      data1_reg <= 1'h0;
      ready1_reg <= 1'h0;
      ctrl_data1_reg <= 1'h0;
    end
    else begin
      automatic logic _GEN_1 = ~_GEN_0 & ~ready0_reg;
      automatic logic _GEN_2 = _GEN_0 & ready0_reg;
      automatic logic _GEN_3 = ~out0_ready & ~ready1_reg;
      automatic logic _GEN_4 = out0_ready & ready1_reg;
      valid0_reg <= _GEN ? in0_valid : valid0_reg;
      data0_reg <= _GEN ? in0 : data0_reg;
      ready0_reg <= ~_GEN_2 & (_GEN_1 ? valid0_reg : ready0_reg);
      ctrl_data0_reg <= ~_GEN_2 & (_GEN_1 ? data0_reg : ctrl_data0_reg);
      valid1_reg <= _GEN_0 ? (ready0_reg ? ready0_reg : valid0_reg) : valid1_reg;
      data1_reg <= _GEN_0 ? (ready0_reg ? ctrl_data0_reg : data0_reg) : data1_reg;
      ready1_reg <= ~_GEN_4 & (_GEN_3 ? valid1_reg : ready1_reg);
      ctrl_data1_reg <= ~_GEN_4 & (_GEN_3 ? data1_reg : ctrl_data1_reg);
    end
  end // always_ff @(posedge)
  assign in0_ready = _GEN;
  assign out0 = ready1_reg ? ctrl_data1_reg : data1_reg;
  assign out0_valid = ready1_reg ? ready1_reg : valid1_reg;
endmodule

